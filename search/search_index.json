{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"compile-time-runtime/","title":"Compile time > runtime","text":"<p>The compiler is a very powerful tool, if being used right.</p> <p>All roads lead to Rome.</p> <p>There are always multiple ways to solve a particular problem. In order to compare solutions, I almost universally stick to Compile time &gt; runtime.</p> <p>The idea is that I do as much work as possible before the software is running in its target environment. Compile time is a simplification here. Depending on the technology it might include things like:</p> <ul> <li>Source code validation</li> <li>Compilation</li> <li>Building artifacts (archives, images, executables, etc.)</li> </ul>"},{"location":"compile-time-runtime/#use-final-a-lot","title":"Use <code>final</code>, a lot","text":"<p>The compiler is one of the most powerful tools in my belt. I try to write my code in a certain way so that I can maximize its power.</p> <p>One prominent example is the compiler\u2019s ability to check that <code>final</code> \u201cvariables\u201d are assigned exactly once before they are used. Assuming we have the following code:</p> <pre><code>T result = null;\n\nswitch (something) {\n    case A: result = inCaseOfA();\n    case B: result = inCaseOfB();\n    case C: result = inCaseOfC();\n}\n\n// do something with A\n</code></pre> <p>When I\u2019m reading this, there are some issues that I\u2019m able to spot immediately.</p> <ol> <li>Lack of explicit default case</li> <li><code>result</code> might still be null afterwards</li> </ol> <p>If I now change the declaration to:</p> <pre><code>final T result;\n</code></pre> <p>Then I successfully handed over this tedious task to check for (some of) the logical errors to the compiler. The compiler immediately complain that there are scenarios in which <code>result</code> was never initialized. Even better, it will also complain about the lack implicit fall-through due to the lack of break statements. That\u2019s something I haven\u2019t even realized when I read it for the first time.</p> <p>I\u2019m obviously writing unit tests for this, so I\u2019d ultimately catch it there. The way I see it, there is no harm in having both, good unit tests and a useful compiler on my side.</p> <p>Since I\u2019m not a big fan of <code>break</code> (needs one additional line per case block), I\u2019d rewrite the whole thing to:</p> <pre><code>final T result = compute(something);\n\nprivate T compute(final Something something) {\n    switch (something) {\n        case A: return inCaseOfA();\n        case B: return inCaseOfB();\n        case C: return inCaseOfC();\n        default: return defaultValue();\n    }\n}\n</code></pre>"},{"location":"compile-time-runtime/#primitive-obsession","title":"Primitive Obsession","text":"<p>There is a certain, well-known anti-pattern or smell, the Primitive Obsession. The pattern to solve that also helps to push runtime errors towards compile time validation:</p> <p>Instead of low level primitives like <code>int</code>, <code>boolean</code> and <code>String</code> one should strive towards typed, immutable value objects. This is especially easy to do with Kotlin, but also Java with Lombok helps:</p> <pre><code>class UserId(private val value: String)\nclass Age(private val value: Int) : Comparable&lt;Age&gt; {\n    operator fun plus(age: Age) = Age(value + age.value)\n    override fun compareTo(other: Age): Int = value.compareTo(other.value)\n}\n</code></pre>"},{"location":"compile-time-runtime/#polymorphism","title":"Polymorphism","text":"<p>The underlying idea (Try to do things early and once.) is also applicable during runtime. I often prefer the use of polymorphic constructs over conditionals. One side effect that I\u2019ve seen a lot is that it pushes conditionals into construction. Usually we\u2019d evaluate conditionals during the whole lifecycle of an object, often repeatedly. By using polymorphism there is often one conditional to decide which implementation to create and compose. That is done at construction time of the object (graph) and no longer when it\u2019s being used.</p> <p>(Polymorphism vs. conditionals deserves a post on its own.)</p>"},{"location":"compile-time-runtime/#related","title":"Related","text":"<ul> <li>Staged Builders</li> <li>Primitive Obsession</li> </ul>"},{"location":"compile-time-runtime/#references","title":"References","text":"<ul> <li>Effective Java (Second Edition), Chapter 4 \u2013 Classes and Interfaces, Joshua Bloch, 2008</li> <li>Hardcore Java, Chapter 2 \u2013 The Final Story, Robert Simmons jr., 2004</li> <li>The Clean Code Talks \u2013 Inheritance, Polymorphism, &amp; Testing</li> <li>The Anti-IF Campaign</li> <li>Replace Conditional with Polymorphism</li> <li>Unconditional Programming</li> </ul>"},{"location":"composition/","title":"Composition","text":"<p>noun: composition, the action of putting things together; formation or construction.</p>"},{"location":"composition/#composition-everywhere","title":"Composition everywhere","text":"<p>What I like about composition is, that it applies to all scales:</p> <ul> <li>Functions and methods</li> <li>Classes</li> <li>Components</li> <li>Applications</li> <li>Systems</li> </ul> <p>The idea is always the same. I try to break up (decompose) a problem into smaller sub-problems and solve them individually (Divide and conquer). Then I\u2019m taking those pieces and compose them to form a solution to the overall problem.</p> <p>What I get in return is:</p> <ul> <li>Focus   I can take one component, work with it and not have to burden myself with the rest.</li> <li>Reusability   I can reuse components whenever I have the same problem again.</li> <li>Isolation   Clean interfaces between components allow me to safely refactor within a component, without the risk of breaking the   rest.</li> </ul>"},{"location":"composition/#inheritance","title":"Inheritance","text":"<p>Personally, I\u2019m not just favoring composition over inheritance. I use composition (almost) exclusively. The one and only use case for inheritance that I see is to interact with frameworks (that didn\u2019t get the memo about inheritance).</p> <p>See also Effective Java: Favor Composition Over Inheritance.</p>"},{"location":"composition/#n1","title":"N+1","text":"<p>There is a consequence of applying composition to design. I often call it the N+1 situation, and it goes like this:</p> <p>Let\u2019s say I start off with one component. Now I start understanding the requirements and responsibilities. Assuming I end up with three distinct responsibilities, ergo three different components.</p> <p>In order to achieve the overall goal I don\u2019t need three pieces, I need one whole. That means I need something that puts the three pieces together, i.e. the integration part. Sometimes, when I have more than just three components, I might even need multiple integrations.</p> <p>I often try to manage expectations by stating early on, that we should expect N+1 components in the end.</p> <p>It\u2019s also important to push back on the notion that a design with N (+1) components is more complex than the original design with just one. Complexity is not determined by the number of parts, but the number of connections. The original one-size-fits-all component had those connections already, but they were implicit and hidden. Yet they still hurt, because I need to understand them in order to successfully work with said component.</p>"},{"location":"composition/#references","title":"References","text":"<ul> <li>Composition over inheritance</li> <li>Rich Hickey - Simple Made Easy</li> </ul>"},{"location":"primitive-obsession/","title":"Primitive Obsession","text":"<p>Primitives have their use, but they shouldn\u2019t be our first choice.</p> <p>When it comes to expressing things like identifiers or age we often tend to immediately jump towards primitives:</p> <pre><code>data class User(\n        val id: Int,\n        val age: Int,\n        val name: String,\n        val email: String)\n</code></pre> <p>There are actually several issues with that.</p> <ol> <li>The compiler is no longer able to type-check. Possible errors, as outlined in the next code sample, are the result.</li> <li>Validation is either often forgotten, or shared as separate methods, not together with the values themselves.</li> </ol> <pre><code>val id = 1337\nval age = 36\nval name = \"D. Fault\"\nval email = \"d.fault@example.org\"\nval user = User(age, id, email, name)\n</code></pre> <p>Instead of low level primitives like <code>Int</code>, <code>Boolean</code> and <code>String</code> one should strive towards typed, immutable value objects:</p> <pre><code>data class User(\n        val id: UserId,\n        val age: Age,\n        val name: String,\n        val email: Email)\n\nclass UserId(private val value: String) {\n    // TODO equals, hashCode, toString\n}\n\nclass Age(private val value: Int) : Comparable&lt;Age&gt; {\n    init {\n        require(value &gt;= 0)\n    }\n\n    operator fun plus(age: Age) = Age(value + age.value)\n    override fun compareTo(other: Age) = value.compareTo(other.value)\n    // TODO equals, hashCode, toString\n}\n\nclass Email(private val value: String) {\n    init {\n        EmailValidator().validate(value)\n    }\n    // TODO equals, hashCode, toString\n}\n</code></pre>"},{"location":"primitive-obsession/#references","title":"References","text":"<ul> <li>Refactoring Guru: Primitive Obsession</li> </ul>"},{"location":"patterns/composite/","title":"Composite","text":""},{"location":"patterns/composite/#intent","title":"\ud83d\udcac Intent","text":"<p>See Refactoring Guru: Composite</p>"},{"location":"patterns/composite/#problem","title":"\u2639\ufe0f Problem","text":"<p>I often stumble upon the following problem. Starting off with a class that accepts a callback of some kind.</p> <pre><code>class UserService(\n    private val repository: UserRepository,\n    private val listener: Listener\n) {\n\n    fun create(user: User) {\n        require(user.isValid())\n        val created = repository.create(user)\n        listener.onCreated(created)\n    }\n}\n</code></pre> <p>Could be a listener, notifier or anything along those lines:</p> <pre><code>interface Listener {\n    fun onCreated(user: User)\n}\n</code></pre> <p>More often than not, I have the need to add support for multiple of callbacks. The straightforward and somewhat compelling implementation looks like this: </p> <pre><code>class UserService(\n    private val repository: UserRepository,\n    private val listeners: List&lt;Listener&gt;\n) {\n\n    fun create(user: User) {\n        require(user.isValid())\n        val created = repository.create(user)\n        listeners.forEach { it.onCreated(created) }\n    }\n}\n</code></pre> <p>It does have a few aspects in its favor:</p> <ul> <li>\u2705 Easy to understand</li> <li>\u2705 Easy to implement</li> </ul> <p>But it comes with a bunch of problems as well:</p> <ul> <li>\u274c Violates the Single-responsibility principle<ul> <li><code>UserService</code> should only change </li> </ul> </li> <li>\u274c Violates the Open-closed principle<ul> <li><code>UserService</code> should not be modified to extend its behavior </li> </ul> </li> </ul> <p>In addition, the proposed implementation base on <code>Collection#forEach</code> is too simplistic. A proper implementation should also take the following into consideration, just to name a few:</p> <ul> <li>\u274c Error handling   If one listener fails, the remaining ones won\u2019t be executed.</li> <li>\u274c Concurrency   Running listeners in parallel.</li> <li>\u274c Asynchrony   Executing listeners asynchronously, not waiting for them to finish.</li> <li>\u274c Dynamic listener de/registration   Allow adding and removing listeners at runtime.   This is not totally trivial in a multi-threaded environments.</li> </ul> <p>Adding support for any of them is not rocket science, but it would increase the complexity of <code>UserService</code> quite a bit.</p>"},{"location":"patterns/composite/#solution","title":"\ud83d\ude0a Solution","text":""},{"location":"patterns/composite/#structure","title":"Structure","text":"<p>Componentrun()CompositeComponentelements: Collection&lt;Component&gt;run()SomeComponentrun()Clientuse</p>"},{"location":"patterns/composite/#pseudocode","title":"Pseudocode","text":"<p>Listenerrun()CompositeListenerlisteners: Collection&lt;Listener&gt;run()LoggingListenerrun()MetricsListenerrun()UserServiceuse</p> <p>The ideal solution addresses all concerns above.</p> <pre><code>class UserService(\n    private val repository: UserRepository,\n    private val listener: Listener\n) {\n    fun create(user: User) {\n        require(user.isValid())\n        val created = repository.create(user)\n        listener.onCreated(created)\n    }\n}\n</code></pre> <p>The <code>UserService</code> didn\u2019t need to change compared to the original design. No principle would be violated:</p> <ul> <li>\u2705 Single-responsibility principle</li> <li>\u2705 Open-closed principle</li> </ul> <p>We create a new class instead:</p> <pre><code>class CompositeListener(\n    internal val listeners: Collection&lt;Listener&gt;,\n) : Listener {\n    override fun onCreated(user: User) {\n        listeners.forEach { it.onCreated(user) }\n    }\n}\n</code></pre> <p>The other concerns could (as needed) all addressed with separate classes using the Decorator pattern:</p> <ul> <li>\u2705 Error handling <pre><code>fun Listener.onError(handler: ErrorHandler) =\n    object : Listener {\n        override fun onCreated(user: User) {\n            try {\n                this@onError.onCreated(user)\n            } catch (e: Exception) {\n                if (!handler.handle(this@onError, e)) return\n            }\n        }\n    }\n</code></pre> <pre><code>interface ErrorHandler {\n    fun handle(listener: Listener, exception: Exception): Boolean\n}\n\nobject Log : ErrorHandler {\n    override fun handle(listener: Listener, exception: Exception): Boolean {\n        TODO(\"Not yet implemented\")\n    }\n}\n\nobject Ignore : ErrorHandler {\n    override fun handle(listener: Listener, exception: Exception): Boolean = true\n}\n</code></pre></li> <li>\u2705 Concurrency   <pre><code>fun CompositeListener.concurrent() =\n    object : Listener {\n        override fun onCreated(user: User) {\n            runBlocking {\n                val async = listeners.map { it.async(this) }\n                CompositeListener(async).onCreated(user)\n            }\n        }\n    }\n</code></pre></li> <li>\u2705 Asynchrony   <pre><code>fun Listener.async(scope: CoroutineScope): Listener =\n    object : Listener {\n        override fun onCreated(user: User) {\n            scope.launch { this@async.onCreated(user) }\n        }\n    }\n</code></pre></li> <li>\u2705 Dynamic listener de/registration   Just pass a <code>CopyOnWriteArrayList</code> to <code>CompositeListener</code> and modify it as needed.</li> </ul> <pre><code>class Usage {\n    fun userService(repository: UserRepository): UserService {\n        return UserService(\n            repository,\n            CompositeListener(listOf(\n                LoggingListener().onError(Log),\n                MetricsListener().onError(Ignore),\n            )).concurrent()\n        )\n    }\n}\n</code></pre>"},{"location":"patterns/composite/#applicability","title":"\ud83d\udca1Applicability","text":""},{"location":"patterns/composite/#how-to-implement","title":"\ud83d\udcdd How to implement","text":""},{"location":"patterns/composite/#pros-and-cons","title":"\u2696\ufe0e Pros and Cons","text":""},{"location":"patterns/composite/#references","title":"References","text":"<ul> <li>Refactoring Guru: Composite</li> <li>SourceMaking: Composite</li> </ul>"},{"location":"patterns/staged-builders/","title":"Staged Builders","text":"<p>[..] often referred to as a wizard for building objects.</p> <p>Another pattern that I like to use a lot is Staged Builder. The traditional implementation of the Builder pattern is usually not very safe against misuse.</p> <p>It\u2019s a pattern that helps with Compile time &gt; runtime because it shifts validation from runtime to compile time.</p> <p>Let\u2019s say there is a builder that produces a User.</p> <pre><code>final var user = new UserBuilder()\n    // misses first name, which is required\n    .withLastname(\"..\")\n    .build()\n</code></pre> <p>The API of <code>UserBuilder</code> doesn\u2019t guide you how to properly use it.</p> <p>The staged builder pattern introduces a proper interface, multiple in fact, without the need to change the builder implementation itself. Apart from the fact that it should be package private then.</p> <pre><code>interface FirstNameStage {\n    LastNameStage withFirstName(String firstName);\n}\n\ninterface LastNameStage {\n    BuildStage withLastName(String lastName);\n}\n\ninterface BuildStage {\n    User build();\n}\n</code></pre> <p>See also Riptide: <code>HttpBuilder</code> which includes an example of mutually exclusive paths.</p>"},{"location":"patterns/staged-builders/#references","title":"References","text":"<ul> <li>Step builder pattern</li> <li>Immutable objects: Staged builder</li> <li>Next level Java 8 staged builders</li> </ul>"},{"location":"patterns/test-contract/","title":"Test contract","text":""},{"location":"patterns/test-contract/#intent","title":"\ud83d\udcac Intent","text":"<p>Test contract or Contract-style unit test is a structural test design pattern that lets you define a contract for an interface and enforce it for every concrete implementation.</p>"},{"location":"patterns/test-contract/#problem","title":"\u2639\ufe0f Problem","text":"<p>Whenever you have an interface, you usually end up with multiple implementations. While these implementations have distinct characteristics that make them different, they should also share a common behavior as specified by the interface. This specification is normally expressed just by the required method signatures and types. But, of course, there are aspects of the specification you can\u2019t describe using the type system alone.</p> <p>That\u2019s when tests come in. A set of tests provides as an executable verification and acts as a guarantee that the system under test actually adheres to the specification or contract.</p> <p>The problem is though, that with multiple implementations, how do you ensure that they all adhere to the same specification?</p>"},{"location":"patterns/test-contract/#solution","title":"\ud83d\ude0a Solution","text":"<p>The solution is to formulate the specification as a set of tests, coded against the interface itself, in a single place, to be reused for each and every single implementation.</p> <p>The approach that I like to use is based on test interfaces using default methods:</p> <p>JUnit Jupiter allows <code>@Test</code>, <code>@RepeatedTest</code>, \u2026 to be declared on interface default methods.</p> <p>JUnit 5 User Guide: 2.13. Test Interfaces and Default Methods</p> <p>You basically create an interface with all the tests you need, defined as default methods. That interface is the test contract and can now be easily re-used for different concrete tests for your different implementations.</p>"},{"location":"patterns/test-contract/#structure","title":"Structure","text":"<p>Thingperform(T): RThingContractFakeThingFakeThingTestRealThingRealThingTestspecifiesteststests</p>"},{"location":"patterns/test-contract/#pseudocode","title":"Pseudocode","text":"<p>This example uses a <code>UserRepository</code> interface and two implementations,  <code>InMemoryUserRepository</code> (a hand-rolled fake) and <code>PostgresUserRepository</code>:</p> <p>UserRepositorycreate(User): Userfind(UserId): User?UserRepositoryContractInMemoryUserRepositoryInMemoryUserRepositoryTestPostgresUserRepositoryPostgresUserRepositoryTestteststests</p> <pre><code>interface UserRepositoryContract {\n\n    val unit: UserRepository\n\n    @Test\n    fun `finds user`() {\n        val expected = unit.create(randomUser())\n        val actual = unit.find(expected.id)\n        assertThat(actual).isEqualTo(expected)\n    }\n\n    @Test\n    fun `won't find absent user`() {\n        val user = unit.create(randomUser())\n        assertThat(user).isNull()\n    }\n}\n</code></pre> <p>Note that there is no implementation specific code in here. Every test is defined using the <code>UserRepository</code> interface. In addition, there is no setup or teardown logic.</p> <p>Tests</p> InMemoryUserRepositoryTestPostgresUserRepository <pre><code>class InMemoryUserRepositoryTest : UserRepositoryContract {\n    override val unit = InMemoryUserRepository()\n}\n</code></pre> <pre><code>@SpringBootTest\n@ContextConfiguration(initializers = [Initializer::class])\n@Testcontainers\nclass PostgresUserRepositoryTest : UserRepositoryContract {\n\n    companion object {\n        @Container\n        @ServiceConnection\n        val postgres = Postgres()\n    }\n\n\n    internal class Initializer : PostgresInitializer(postgres)\n\n    @Import(PostgresUserRepository::class)\n    @Configuration\n    @ImportAutoConfiguration(\n        classes = [\n            DataSourceAutoConfiguration::class,\n            FlywayAutoConfiguration::class,\n            JdbcTemplateAutoConfiguration::class,\n        ],\n    )\n    open class TestConfiguration\n\n    @Autowired\n    override lateinit var unit: PostgresUserRepository\n\n    @Autowired\n    private lateinit var jdbc: NamedParameterJdbcTemplate\n\n\n    @BeforeEach\n    @AfterEach\n    fun truncate() {\n        jdbc.update(\"TRUNCATE my_table\", emptyMap&lt;String, Any&gt;())\n    }\n}\n\nclass Postgres : PostgreSQLContainer&lt;Postgres&gt;(\"postgres:16\")\n\nabstract class PostgresInitializer(private val postgres: Postgres) :\n    ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; {\n\n    override fun initialize(configurableApplicationContext: ConfigurableApplicationContext) {\n        TestPropertyValues.of(\n            \"spring.flyway.user: ${postgres.username}\",\n            \"spring.flyway.password: ${postgres.password}\",\n            \"spring.datasource.url: ${postgres.jdbcUrl}\",\n            \"spring.datasource.username: user\",\n            \"spring.datasource.password: password\",\n        ).applyTo(configurableApplicationContext.environment)\n    }\n}\n</code></pre>"},{"location":"patterns/test-contract/#transfer-of-confidence","title":"Transfer of confidence","text":"<p>You have two implementations, one for production that is too slow for tests and one that isn\u2019t for production but is fast.</p> <p>The test for your production variant gives you confidence for production. Since a test contract executes and verifies the same tests against your fake, you can now be confident that you can use the fake whenever you\u2019d usually need the production variant.</p> <p>The test contract allows you to transfer the trust from one implementation to another. In other words, it\u2019s a way to verify the Liskov substitution principle.</p>"},{"location":"patterns/test-contract/#alternatives","title":"Alternatives","text":"<p>There are some options you could use:</p>"},{"location":"patterns/test-contract/#abstract-test-class","title":"Abstract test class","text":"<p>While it works, it\u2019s not ideal. You can only have one base class and e.g. some database testing libraries/frameworks require you to use class inheritance which is then no longer possible. Also, I\u2019m not a big fan of inheritance and favor composition whenever I can.</p>"},{"location":"patterns/test-contract/#parameterizedtest","title":"<code>@ParameterizedTest</code>","text":"<p>\u2026 using instances of all implementations as the parameters. Technically doable, but it would also require to have all setup and teardown logic for all implementations in a single test - which will quickly become a maintenance nightmare.</p> <p>Both of these also share the downside that one can\u2019t easily split the tests up into smaller test classes, because one would need to repeat itself - a lot.</p>"},{"location":"patterns/test-contract/#references","title":"References","text":"<ul> <li>JUnit 5 User Guide: 2.13. Test Interfaces and Default Methods</li> <li>Liskov substitution principle</li> </ul>"},{"location":"patterns/time-dependent/","title":"Time-dependent","text":"<p>Dependency injection doesn\u2019t end <code>now()</code>.</p> <p>There are certain constructs and expressions that immediately raise a red flag, whenever I see them:</p> <ul> <li><code>now()</code> within <code>Instant</code>, <code>OffsetDateTime</code>, etc.</li> <li><code>new Date()</code> or <code>Calendar.getInstance()</code> (also because they are deprecated)</li> <li><code>current_date</code>, <code>current_time</code> and <code>current_timestamp</code></li> </ul> <p>Pretty much everything that uses the system clock. My main concern is that it makes the code hard to test, slow to test or both.</p> <p>Let\u2019s say I have this campaign class. A campaign has a start and end date. Now I\u2019d like to have an easy way to tell whether it\u2019s currently active:</p> <pre><code>class Campaign(private val start: Instant, private val end: Instant) {\n\n    fun isActive(): Boolean {\n        val now = Instant.now()\n        return start &lt;= now &amp;&amp; now &lt;= end\n    }\n\n}\n</code></pre> <p>The code is relatively easy to understand, but it\u2019s almost impossible to test, unless I:</p> <ul> <li>Mock the static <code>Instant.now()</code> method</li> <li>Change the actual system clock for the test</li> <li>Produce dynamic start and end dates, depending on the current time</li> </ul> <p>Neither of those options is ideal. I\u2019d rather have a test that:</p> <ul> <li>Works only with constants</li> <li>Is independent of the system\u2019s clock it\u2019s running on</li> <li>Is fast, i.e. not waiting or sleeping</li> </ul> <pre><code>@Test\nfun `campaign is active`() {\n    val start = Instant.parse(\"2020-12-13T11:00:00.00Z\")\n    val end = Instant.parse(\"2020-12-25T11:00:00.00Z\")\n    val unit = Campaign(start, end)\n\n    assertTrue(unit.isActive())\n}\n</code></pre> <p>In order to make that pass, I\u2019d change the code and test to:</p> <pre><code>fun isActive(now: Instant): Boolean {\n    return start &lt;= now &amp;&amp; now &lt;= end\n}\n\nval now = Instant.parse(\"2020-12-19T09:32:17.00Z\")\nassertTrue(unit.isActive(now))\n</code></pre> <p>I can now:</p> <ul> <li>Have as many of those tests as I want.</li> <li>Properly test the boundaries without running into race conditions.</li> <li>Check whether a campaign was active in the past or will be active in the future, just by passing in a different reference timestamp.</li> </ul>"},{"location":"patterns/time-dependent/#clock","title":"Clock","text":"<p>There are cases where I can\u2019t or don\u2019t want to pass in an <code>Instant</code> directly. The next best thing is to introduce an indirect dependency onto a <code>Clock</code>. That clock is then passed in as a constructor argument.</p> <p>That dependency can be replaced by a fixed clock or a fake clock during tests. In production, it would then be <code>Clock.systemUTC()</code>.</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.mercateo&lt;/groupId&gt;\n  &lt;artifactId&gt;test-clock&lt;/artifactId&gt;\n  &lt;version&gt;1.0.2&lt;/version&gt;\n  &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"patterns/time-dependent/#spring-scheduling","title":"Spring Scheduling","text":"<p>Passing a clock explicitly as a dependency also works with the latest version of Spring Scheduling:</p> <pre><code>@EnableScheduling\nclass SchedulingConfiguration {\n\n    @Bean\n    fun taskScheduler(clock: Clock): TaskScheduler {\n        val scheduler = ThreadPoolTaskScheduler()\n        scheduler.clock = clock\n        scheduler.poolSize = 5\n        scheduler.threadNamePrefix = \"ThreadPoolTaskScheduler\"\n        return scheduler\n    }\n}\n</code></pre>"},{"location":"patterns/time-dependent/#database","title":"Database","text":"<p>Eliminating time dependency is not limited to traditional programming languages. Especially within the database queries, e.g. SQL, it applies in exactly the same way.</p> <p>Assuming I have this query to find active logins (not older than 5 minutes):</p> <pre><code>SELECT COUNT(1)\n  FROM logins\n WHERE AGE(created_at, current_timestamp) &lt; '5 minutes'::INTERVAL \n</code></pre> <p>The query is pretty straightforward to write, but it\u2019s very hard to test. I can either execute an additional statement, exclusive to my test:</p> <pre><code>@Test\nfun `only finds logins that are five minutes old or less`() {\n    val login = login()\n    execute(\"UPDATE logins SET created_at = created_at - '5 Minutes'::INTERVAL WHERE id = ${login.id}\")\n    assertThat(findLoginsLastFiveMinutes()).isEmpty()\n}\n</code></pre> <p>Or I can actually wait for 5 minutes. (Don\u2019t do that!)</p> <pre><code>@Test\nfun `only finds logins that are five minutes old or less`() {\n    val login = login()\n    Thread.sleep(Duration.ofMinutes(5).toMillis())\n    assertThat(findLoginsLastFiveMinutes()).isEmpty()\n}\n</code></pre> <p>If I rewrite the statement instead and depend on now being passed in:</p> <pre><code>SELECT COUNT(1)\n  FROM logins\n WHERE AGE(created_at, :now) &lt; '5 minutes'::INTERVAL \n</code></pre> <p>Then I can change my test to:</p> <pre><code>val clock = TestClock()\nval unit = UserRepository(clock)\n\n@Test\nfun `only finds logins that are five minutes old or less`() {\n    val login = login()\n    clock.fastForward(Duration.ofMinutes(5))\n    assertThat(findLoginsLastFiveMinutes()).isEmpty()\n}\n</code></pre> <p>The benefits of doing that are huge:</p> <ul> <li>Test no longer needs to execute a custom SQL statement</li> <li>Test is not sleeping/waiting/idling, i.e. it\u2019s fast</li> <li>Production code is more powerful than before:    I can now find active logins at an arbitrary point in time, if I want to.</li> </ul>"},{"location":"patterns/time-dependent/#references","title":"References","text":"<ul> <li>Test Clock, a great small library to have a mutable <code>Clock</code> implementation</li> </ul>"},{"location":"practices/hand-roll-test-doubles/","title":"Hand-roll test doubles","text":"<p>\u201cI\u2019m long past on record that I think the use of auto-mockers [\u2026] is bad policy.\u201d \u2014 GeePaw Hill, July 13<sup>th</sup>, 2021</p> <p>Mocking libraries<sup>1</sup> are everywhere these days, promising easy test setup and readable code. But honestly, sometimes it\u2019s way better to just roll your own test doubles. Especially if you care about clean, maintainable tests. Let\u2019s talk about why explicit code often beats the magic of mocking frameworks.</p>"},{"location":"practices/hand-roll-test-doubles/#what-are-test-doubles-anyway","title":"What are Test Doubles Anyway?","text":"<p>Test doubles are objects that stand in for real dependencies during testing. They allow you to isolate the unit under test, controlling its interactions with other parts of the system and ensuring predictable test outcomes.</p> <p>Before using test doubles, consider whether you can use the real dependency; if it\u2019s cheap, fast, and safe, using the real thing is preferable. This approach aligns with the concept of sociable unit tests, which verify the behavior of multiple components in collaboration. Test doubles should only be used when using the real dependency is impractical or problematic.</p> <p>Here are the common types:</p> <ul> <li> <p>Dummies</p> <p>These are objects passed as arguments but are never actually used within the method being tested. They are simply placeholders to satisfy method signatures.</p> </li> <li> <p>Stubs</p> <p>Stubs provide canned answers to method calls (indirect input). They simplify test setup by returning predefined values, avoiding complex setup of real dependencies.</p> </li> <li> <p>Spies</p> <p>Spies are a bit more nuanced than stubs. They \u201cspy\u201d on the interactions with the real object (or a partial mock) for indirect output. There are two main types of spies:</p> <ul> <li> <p>Interaction-based</p> <p>These are the type of spies commonly implemented by mocking libraries. They focus on verifying how a dependency was used. They track method calls, the arguments passed to those methods, and the order of calls.</p> </li> <li> <p>State-based</p> <p>These spies focus on observing the state changes of the object being spied on. Instead of verifying specific method calls, they verify that the object\u2019s internal state has changed in the expected way as a result of the interaction.</p> </li> </ul> </li> <li> <p>Mocks</p> <p>Mocks are pre-programmed with expectations about how they will be called. If these expectations are not met during the test, the test fails. Mocks are used to verify interactions and enforce specific behavior.</p> </li> <li> <p>Fakes</p> <p>Fakes are working implementations of a dependency, but they are simplified for testing purposes. Examples include in-memory databases or simplified versions of external services. They provide a functional but lightweight alternative to the real dependency.</p> </li> </ul>"},{"location":"practices/hand-roll-test-doubles/#the-problem-with-mocking-libraries","title":"The Problem with Mocking Libraries","text":"<p>While mocking libraries offer convenient test double creation and reduced boilerplate, they also present noteworthy drawbacks:</p> <ul> <li> <p>Mocks are not aware of the interface contract</p> <p>Mocks only know about the specific methods and behaviors you explicitly define in each test. This means there\u2019s no compile-time or runtime check to ensure these mock setups adhere to the actual interface contract. This lack of enforcement creates a significant risk of introducing subtle errors that can go undetected.</p> </li> <li> <p>Tight Coupling to Implementation</p> <p>Overusing mocks ties tests to internal implementation details. Refactoring internal code, even without changing the public interface, can break numerous tests, hindering refactoring efforts.</p> </li> <li> <p>Testing Interactions, Not Behavior</p> <p>Mocking often focuses on verifying interactions (how dependencies are used) rather than behavior (what the code achieves). This leads to brittle tests that don\u2019t effectively validate the intended functionality.</p> </li> <li> <p>\u201cMagic\u201d and Increased Complexity</p> <p>Mocking libraries rely on complex mechanisms and introduce their own APIs, creating a \u201cmagic\u201d layer that obscures test behavior and increases the learning curve. This makes tests harder to understand, debug, and maintain, especially for newcomers.</p> </li> </ul>"},{"location":"practices/hand-roll-test-doubles/#why-hand-rolling-is-often-better","title":"Why Hand-Rolling is Often Better","text":"<p>Hand-rolled test doubles offer several compelling advantages over mocking libraries:</p> <ul> <li> <p>Direct Interface Design Feedback</p> <p>Creating hand-rolled test doubles provides immediate feedback on your interface design. If a test double becomes complex, it suggests the interface it\u2019s doubling is too complex, prompting you to apply principles like the Interface Segregation Principle for cleaner code.</p> </li> <li> <p>Testable Test Doubles</p> <p>Hand-rolled test doubles, especially fakes, are regular classes that can be independently tested. This ensures their correctness and enhances the reliability of your system\u2019s tests, especially when fakes contain complex logic. Check out Test contract for a good way to test fakes.</p> </li> <li> <p>Explicit and Understandable Code</p> <p>Hand-rolled doubles are written directly in your test code, making them easy to understand, debug, and maintain. Their behavior is entirely explicit, avoiding the \u201cmagic\u201d of mocking frameworks.</p> </li> <li> <p>Reduced Coupling to Implementation</p> <p>By focusing on essential behavior, hand-rolled doubles minimize coupling to implementation details. This makes your tests more resilient to refactoring, as internal changes are less likely to break them.</p> </li> <li> <p>Tests Focused on Behavior</p> <p>Hand-rolling encourages you to focus on the inputs and outputs relevant to the test, promoting behavior-driven testing. This results in more expressive and maintainable tests that focus on what the code does, not how.</p> </li> <li> <p>Simplified Debugging</p> <p>When a test with hand-rolled doubles fails, debugging is easier because the test double\u2019s behavior is directly visible in the code. You avoid the need to delve into complex mocking framework internals.</p> </li> </ul>"},{"location":"practices/hand-roll-test-doubles/#examples","title":"Examples","text":"<p>This section demonstrates hand-rolled test doubles in Kotlin, showcasing each of the five main types:</p> DummyStubSpiesMockFake <p>Warning</p> <p>Only hand-roll a dummy if a suitable default/noop implementation (like a Null Object) doesn\u2019t already exist for the required interface.</p> <pre><code>interface Currency {\n    val code: String\n    val symbol: String\n    val displayName: String\n    val defaultFractionDigits: Int\n}\n\ndata class Money(val amount: BigDecimal, val currency: Currency)\n\ndata object EUR : Currency {\n    override val code: String = \"EUR\"\n    override val symbol: String = \"\u20ac\"\n    override val displayName: String = \"Euro\"\n    override val defaultFractionDigits: Int = 2\n}\n\ndata object USD : Currency {\n    override val code = \"USD\";\n    override val symbol = \"$\";\n    override val displayName = \"US Dollar\";\n    override val defaultFractionDigits = 2\n}\n\ninterface CurrencyConverter {\n    fun convert(amount: Money, preferredCurrency: Currency): Money\n}\n\n/**\n * Converts amounts to EUR.  Ignores the [preferredCurrency] parameter.\n */\nclass EuroConverter : CurrencyConverter {\n    override fun convert(amount: Money, preferredCurrency: Currency): Money {\n        val euroAmount = when (amount.currency.code) {\n            \"USD\" -&gt; amount.amount.multiply(BigDecimal(\"0.92\"))\n            \"GBP\" -&gt; amount.amount.multiply(BigDecimal(\"1.15\"))\n            else -&gt; amount.amount\n        }\n        return Money(euroAmount, EUR)\n    }\n\n}\n</code></pre> <pre><code>data object DummyCurrency : Currency {\n    override val code: String\n        get() = throw UnsupportedOperationException(\"Dummy Currency should not be used.\")\n\n    override val symbol: String\n        get() = throw UnsupportedOperationException(\"Dummy Currency should not be used.\")\n\n    override val displayName: String\n        get() = throw UnsupportedOperationException(\"Dummy Currency should not be used.\")\n\n    override val defaultFractionDigits: Int\n        get() = throw UnsupportedOperationException(\"Dummy Currency should not be used.\")\n}\n</code></pre> <pre><code>class EuroConverterTest {\n    @Test\n    fun `converts to eur ignoring preferred currency`() {\n        val converter = EuroConverter()\n        val amount = Money(BigDecimal(\"100\"), USD)\n        val dummyCurrency = DummyCurrency\n\n        val convertedAmount = converter.convert(amount, dummyCurrency)\n\n        assertEquals(BigDecimal(\"92.00\"), convertedAmount.amount)\n        assertEquals(\"EUR\", convertedAmount.currency.code)\n    }\n}\n</code></pre> <p>Tip</p> <p>This example uses the Configurable Responses pattern as implemented by whiskeysierra/test-doubles.</p> <pre><code>interface DataProvider {\n    fun getData(id: Int): String?\n}\n\nclass DataProcessor(private val dataProvider: DataProvider) {\n    fun process(id: Int, fallback: String = \"Default Data\"): String {\n        return \"Processed: ${dataProvider.getData(id) ?: fallback}\"\n    }\n}\n</code></pre> <pre><code>class StubDataProvider(private val responses: Iterator&lt;String?&gt;) : DataProvider {\n    override fun getData(id: Int) = responses.next()\n}\n</code></pre> <pre><code>class DataProcessorTest {\n    @Test\n    fun `retrieves and processes data`() {\n        val provider = StubDataProvider(responses = once(\"Test Data\", null, \"Other Data\"))\n        val processor = DataProcessor(provider)\n\n        assertEquals(\"Processed: Test Data\", processor.process(1))\n        assertEquals(\"Processed: Default Data\", processor.process(2))\n        assertEquals(\"Processed: Other Data\", processor.process(3))\n    }\n\n    @Test\n    fun `uses fallback when no data is available`() {\n        val provider = StubDataProvider(responses = once(null, \"Real Data\"))\n        val processor = DataProcessor(provider)\n\n        assertEquals(\"Processed: Fallback Data\", processor.process(4, \"Fallback Data\"))\n        assertEquals(\"Processed: Real Data\", processor.process(5, \"Fallback Data\"))\n    }\n}\n</code></pre> <p>Tip</p> <p>This example uses the Output Tracking pattern as implemented by whiskeysierra/test-doubles.</p> <pre><code>interface EmailService {\n    fun sendEmail(recipient: String, message: String)\n}\n\nclass UserNotifier(private val emailService: EmailService) {\n    fun notifyUser(userEmail: String, message: String) {\n        emailService.sendEmail(userEmail, message)\n        emailService.sendEmail(\"admin@example.com\", \"User notified\") // Send notification to admin as well\n    }\n}\n</code></pre> <pre><code>import io.github.whiskeysierra.testdoubles.spy.OutputTracking\nimport io.github.whiskeysierra.testdoubles.spy.Tracker\nimport org.assertj.core.util.VisibleForTesting\n\nclass SpyEmailService : EmailService {\n    private val tracking = OutputTracking&lt;Pair&lt;String, String&gt;&gt;()\n\n    @VisibleForTesting\n    fun track(): Tracker&lt;Pair&lt;String, String&gt;&gt; = tracking.track()\n\n    override fun sendEmail(recipient: String, message: String) {\n        tracking.add(Pair(recipient, message))\n    }\n}\n</code></pre> <pre><code>import io.github.whiskeysierra.testdoubles.spy.Tracker\nimport org.assertj.core.api.Assertions.assertThat\nimport org.junit.jupiter.api.Test\n\nclass UserNotifierTest {\n    @Test\n    fun `sends emails to user and admin`() {\n        val spy = SpyEmailService()\n        val notifier = UserNotifier(spy)\n\n        val sentEmails: Tracker&lt;Pair&lt;String, String&gt;&gt; = spy.track()\n\n        notifier.notifyUser(\"test@example.com\", \"Hello!\")\n\n        assertThat(sentEmails).containsExactly(\n            Pair(\"test@example.com\", \"Hello!\"),\n            Pair(\"admin@example.com\", \"User notified\")\n        )\n    }\n}\n</code></pre> <p>A Word of Caution</p> <p>While hand-rolling mocks is technically possible (as shown below), it\u2019s often less ideal than using simpler types of test doubles.</p> <p>Hand-rolled mocks present two key challenges. First, the need to pre-program and verify expectations increases the complexity of the mock itself, making it harder to write, understand, and maintain. Second, and this applies to mocks in general, hiding expectations and verifications within the mock makes the tests themselves less expressive and readable, as they contain less visible evidence (assertions). Consider using simpler test doubles like stubs, spies, or fakes before resorting to hand-rolled mocks.</p> <pre><code>interface PaymentGateway {\n    fun processPayment(amount: Double): Boolean\n}\n\nclass OrderProcessor(private val paymentGateway: PaymentGateway) {\n    fun processOrder(amount: Double) {\n        if (!paymentGateway.processPayment(amount)) {\n            throw PaymentFailedException(\"Payment failed for amount: $amount\")\n        }\n        // Order processing logic here\n    }\n}\n\nclass PaymentFailedException(message: String) : RuntimeException(message)\n</code></pre> <pre><code>class MockPaymentGateway : PaymentGateway {\n    private var paymentProcessed = false\n    private var expectedAmount: Double? = null\n    var wasCalled = false\n\n    fun willReturn(value: Boolean) {\n        paymentProcessed = value\n    }\n\n    fun expectPaymentOf(amount: Double) {\n        expectedAmount = amount\n    }\n\n    override fun processPayment(amount: Double): Boolean {\n        wasCalled = true\n        if (expectedAmount != null &amp;&amp; expectedAmount != amount) {\n            throw AssertionError(\"Expected payment of $expectedAmount but received $amount\")\n        }\n        return paymentProcessed\n    }\n}\n</code></pre> <pre><code>class OrderProcessorTest {\n\n    @Test\n    fun `processOrder successfully processes payment`() {\n        val mock = MockPaymentGateway()\n        mock.willReturn(true)\n        val processor = OrderProcessor(mock)\n        processor.processOrder(100.0)\n        assert(mock.wasCalled)\n    }\n\n    @Test\n    fun `processOrder throws exception when payment fails`() {\n        val mock = MockPaymentGateway()\n        mock.willReturn(false)\n        val processor = OrderProcessor(mock)\n\n        assertThrows&lt;PaymentFailedException&gt; {\n            processor.processOrder(50.0)\n        }\n        assert(mock.wasCalled)\n    }\n\n    @Test\n    fun `processOrder checks the amount passed to the payment gateway`() {\n        val mock = MockPaymentGateway()\n        mock.expectPaymentOf(200.0)\n        mock.willReturn(true)\n        val processor = OrderProcessor(mock)\n        processor.processOrder(200.0)\n        assert(mock.wasCalled)\n    }\n\n    @Test\n    fun `processOrder throws assertion if unexpected amount passed`() {\n        val mock = MockPaymentGateway()\n        mock.expectPaymentOf(200.0)\n        val processor = OrderProcessor(mock)\n        assertThrows&lt;AssertionError&gt; {\n            processor.processOrder(100.0)\n        }\n        assert(mock.wasCalled)\n    }\n}\n</code></pre> <p>Tip</p> <p>Fakes are particularly well-suited for implementing repository interfaces because they provide simplified, in-memory implementations that mimic the behavior of a real database or external service, making tests fast and predictable.</p> <pre><code>interface UserRepository {\n    fun getUser(id: Int): User?\n    fun saveUser(user: User)\n    fun deleteUser(id: Int)\n}\n\ndata class User(val id: Int, val name: String)\n\nclass UserService(private val userRepository: UserRepository) {\n    fun findUser(id: Int): String? {\n        return userRepository.getUser(id)?.name\n    }\n\n    fun createUser(name: String): Int {\n        // In real app, you would use a proper ID generation strategy\n        val newId = (0..Int.MAX_VALUE).random()\n        userRepository.saveUser(User(newId, name))\n        return newId\n    }\n\n    fun removeUser(id: Int) {\n        userRepository.deleteUser(id)\n    }\n}\n</code></pre> <pre><code>class InMemoryUserRepository : UserRepository {\n    private val users = mutableMapOf&lt;Int, User&gt;()\n\n    override fun getUser(id: Int): User? {\n        return users[id]\n    }\n\n    override fun saveUser(user: User) {\n        users[user.id] = user\n    }\n\n    override fun deleteUser(id: Int) {\n        users.remove(id)\n    }\n}\n</code></pre> <pre><code>class UserServiceTest {\n\n    @Test\n    fun `finds user if user exists`() {\n        val repository = InMemoryUserRepository()\n        val userService = UserService(repository)\n        val testUser = User(1, \"Test User\")\n        repository.saveUser(testUser)\n\n        val userName = userService.findUser(1)\n        assertEquals(\"Test User\", userName)\n    }\n\n    @Test\n    fun `doesn't find user if user does not exist`() {\n        val repository = InMemoryUserRepository()\n        val userService = UserService(repository)\n\n        val userName = userService.findUser(999)\n        assertNull(userName)\n    }\n\n    @Test\n    fun `creates the user`() {\n        val repository = InMemoryUserRepository()\n        val userService = UserService(repository)\n\n        val newUserId = userService.createUser(\"New User\")\n        val retrievedUser = repository.getUser(newUserId)\n\n        assertEquals(\"New User\", retrievedUser?.name)\n    }\n\n    @Test\n    fun `deletes the user`() {\n        val repository = InMemoryUserRepository()\n        val userService = UserService(repository)\n        val testUser = User(1, \"Test User\")\n        repository.saveUser(testUser)\n\n        userService.removeUser(1)\n\n        val retrievedUser = repository.getUser(1)\n        assertNull(retrievedUser)\n    }\n}\n</code></pre>"},{"location":"practices/hand-roll-test-doubles/#conclusion","title":"Conclusion","text":"<p>Mocking libraries have their place, especially for complex, existing interfaces or external dependencies you can\u2019t easily replicate But for many cases, hand-rolled test doubles are a much better choice. They lead to simpler, more maintainable tests and give you valuable feedback on your design. So, before reaching for a mocking library, take a moment to consider if a simple hand-rolled double might do the trick. You might be surprised how often it\u2019s the right answer.</p>"},{"location":"practices/hand-roll-test-doubles/#testing-without-mocks","title":"Testing Without Mocks","text":"<p>As astute readers may have noticed, this discussion draws on several patterns from James Shore\u2019s Testing Without Mocks article. It is packed with useful testing tricks and techniques, from test design to dependency management, offering practical ways to improve test clarity, maintainability, and effectiveness. Even if you\u2019re not buying into the whole premise, checking out these patterns can seriously improve your test design.</p>"},{"location":"practices/hand-roll-test-doubles/#references","title":"References","text":"<ul> <li>On not using Mocking Frameworks</li> <li>Test Double</li> <li>Mocks, Fakes, Stubs and Dummies</li> <li>Configurable Responses</li> <li>Output Tracking</li> </ul> <ol> <li> <p>For example Mockito or MockK \u21a9</p> </li> </ol>"}]}