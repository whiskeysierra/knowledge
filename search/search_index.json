{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"2020-12-12-compile-time-runtime/","text":"The compiler is a very powerful tool, if being used right. All roads lead to Rome. There are always multiple ways to solve a particular problem. In order to compare solutions, I almost universally stick to Compile time > runtime . The idea is that I do as much work as possible before the software is running in its target environment. Compile time is a simplification here. Depending on the technology it might include things like: Source code validation Compilation Building artifacts (archives, images, executables, etc.) Use final , a lot \u00b6 The compiler is one of the most powerful tools in my belt. I try to write my code in a certain way so that I can maximize its power. One prominent example is the compiler\u2019s ability to check that final \u201cvariables\u201d are assigned exactly once before they are used. Assuming we have the following code: T result = null ; switch ( something ) { case A : result = inCaseOfA (); case B : result = inCaseOfB (); case C : result = inCaseOfC (); } // do something with A When I\u2019m reading this, there are some issues that I\u2019m able to spot immediately. Lack of explicit default case result might still be null afterwards If I now change the declaration to: final T result ; Then I successfully handed over this tedious task to check for (some of) the logical errors to the compiler. The compiler immediately complain that there are scenarios in which result was never initialized. Even better, it will also complain about the lack implicit fall-through due to the lack of break statements. That\u2019s something I haven\u2019t even realized when I read it for the first time. I\u2019m obviously writing unit tests for this, so I\u2019d ultimately catch it there. The way I see it, there is no harm in having both, good unit tests and a useful compiler on my side. Since I\u2019m not a big fan of break (needs one additional line per case block), I\u2019d rewrite the whole thing to: final T result = compute ( something ); private T compute ( final Something something ) { switch ( something ) { case A : return inCaseOfA (); case B : return inCaseOfB (); case C : return inCaseOfC (); default : return defaultValue (); } } Primitive Obsession \u00b6 There is a certain, well-known anti-pattern or smell, the Primitive Obsession . The pattern to solve that also helps to push runtime errors towards compile time validation: Instead of low level primitives like int , boolean and String one should strive towards typed, immutable value objects. This is especially easy to do with Kotlin, but also Java with Lombok helps: class UserId ( private val value : String ) class Age ( private val value : Int ) : Comparable < Age > { operator fun plus ( age : Age ) = Age ( value + age . value ) override fun compareTo ( other : Age ): Int = value . compareTo ( other . value ) } Runtime \u00b6 The underlying idea ( Try to do things early and once. ) is also applicable during runtime. I often prefer polymorphic constructs over conditionals. One side effect that I\u2019ve seen a lot is that it pushes conditionals into construction. Usually we\u2019d evaluating conditionals during the whole lifecycle of an object, often repeatedly. By using polymorphism there is often one conditional to decide which implementation to create and compose. That is done at construction time of the object (graph) and no longer when it\u2019s being used. ( Polymorphism vs. conditionals deserves a post on its own.) Related \u00b6 Staged Builders Primitive Obsession References \u00b6 Effective Java (Second Edition), Chapter 4 \u2013 Classes and Interfaces, Joshua Bloch, 2008 Hardcore Java, Chapter 2 \u2013 The Final Story, Robert Simmons jr., 2004","title":"Compile time > runtime"},{"location":"2020-12-12-compile-time-runtime/#use-final-a-lot","text":"The compiler is one of the most powerful tools in my belt. I try to write my code in a certain way so that I can maximize its power. One prominent example is the compiler\u2019s ability to check that final \u201cvariables\u201d are assigned exactly once before they are used. Assuming we have the following code: T result = null ; switch ( something ) { case A : result = inCaseOfA (); case B : result = inCaseOfB (); case C : result = inCaseOfC (); } // do something with A When I\u2019m reading this, there are some issues that I\u2019m able to spot immediately. Lack of explicit default case result might still be null afterwards If I now change the declaration to: final T result ; Then I successfully handed over this tedious task to check for (some of) the logical errors to the compiler. The compiler immediately complain that there are scenarios in which result was never initialized. Even better, it will also complain about the lack implicit fall-through due to the lack of break statements. That\u2019s something I haven\u2019t even realized when I read it for the first time. I\u2019m obviously writing unit tests for this, so I\u2019d ultimately catch it there. The way I see it, there is no harm in having both, good unit tests and a useful compiler on my side. Since I\u2019m not a big fan of break (needs one additional line per case block), I\u2019d rewrite the whole thing to: final T result = compute ( something ); private T compute ( final Something something ) { switch ( something ) { case A : return inCaseOfA (); case B : return inCaseOfB (); case C : return inCaseOfC (); default : return defaultValue (); } }","title":"Use final, a lot"},{"location":"2020-12-12-compile-time-runtime/#primitive-obsession","text":"There is a certain, well-known anti-pattern or smell, the Primitive Obsession . The pattern to solve that also helps to push runtime errors towards compile time validation: Instead of low level primitives like int , boolean and String one should strive towards typed, immutable value objects. This is especially easy to do with Kotlin, but also Java with Lombok helps: class UserId ( private val value : String ) class Age ( private val value : Int ) : Comparable < Age > { operator fun plus ( age : Age ) = Age ( value + age . value ) override fun compareTo ( other : Age ): Int = value . compareTo ( other . value ) }","title":"Primitive Obsession"},{"location":"2020-12-12-compile-time-runtime/#runtime","text":"The underlying idea ( Try to do things early and once. ) is also applicable during runtime. I often prefer polymorphic constructs over conditionals. One side effect that I\u2019ve seen a lot is that it pushes conditionals into construction. Usually we\u2019d evaluating conditionals during the whole lifecycle of an object, often repeatedly. By using polymorphism there is often one conditional to decide which implementation to create and compose. That is done at construction time of the object (graph) and no longer when it\u2019s being used. ( Polymorphism vs. conditionals deserves a post on its own.)","title":"Runtime"},{"location":"2020-12-12-compile-time-runtime/#related","text":"Staged Builders Primitive Obsession","title":"Related"},{"location":"2020-12-12-compile-time-runtime/#references","text":"Effective Java (Second Edition), Chapter 4 \u2013 Classes and Interfaces, Joshua Bloch, 2008 Hardcore Java, Chapter 2 \u2013 The Final Story, Robert Simmons jr., 2004","title":"References"},{"location":"2020-12-12-composition/","text":"noun : composition , the action of putting things together; formation or construction. Composition everywhere \u00b6 What I like about composition is, that it applies to all scales: Functions and methods Classes Components Applications Systems The idea is always the same. I try to break up (decompose) a problem into smaller sub-problems and solve them individually ( Divide and conquer ). Then I\u2019m taking those pieces and compose them to form a solution to the overall problem. What I get in return is: Focus I can take one component, work with it and not have to burden myself with the rest. Reusability I can reuse components whenever I have the same problem again. Isolation Clean interfaces between components allow me to safely refactor within a component, without the risk of breaking the rest. Inheritance \u00b6 Personally, I\u2019m not just favoring composition over inheritance. I use composition (almost) exclusively. The one and only use case for inheritance that I see is to interact with frameworks (that didn\u2019t get the memo about inheritance). See also Effective Java: Favor Composition Over Inheritance . N+1 \u00b6 There is a consequence of applying composition to design. I often call it the N+1 situation, and it goes like this: Let\u2019s say I start off with one component. Now I start understanding the requirements and responsibilities. Assuming I end up with three distinct responsibilities, ergo three different components. In order to achieve the overall goal I don\u2019t need three pieces, I need one whole. That means I need something that puts the three pieces together, i.e. the integration part. Sometimes, when I have more than just three components, I might even need multiple integrations. I often try to manage expectations by stating early on, that we should expect N+1 components in the end. It\u2019s also important to push back on the notion that a design with N (+1) components is more complex than the original design with just one. Complexity is not determined by the number of parts, but the number of connections. The original one-size-fits-all component had those connections already, but they were implicit and hidden. Yet they still hurt, because I need to understand them in order to successfully work with said component. References \u00b6 Composition over inheritance Rich Hickey - Simple Made Easy","title":"Composition"},{"location":"2020-12-12-composition/#composition-everywhere","text":"What I like about composition is, that it applies to all scales: Functions and methods Classes Components Applications Systems The idea is always the same. I try to break up (decompose) a problem into smaller sub-problems and solve them individually ( Divide and conquer ). Then I\u2019m taking those pieces and compose them to form a solution to the overall problem. What I get in return is: Focus I can take one component, work with it and not have to burden myself with the rest. Reusability I can reuse components whenever I have the same problem again. Isolation Clean interfaces between components allow me to safely refactor within a component, without the risk of breaking the rest.","title":"Composition everywhere"},{"location":"2020-12-12-composition/#inheritance","text":"Personally, I\u2019m not just favoring composition over inheritance. I use composition (almost) exclusively. The one and only use case for inheritance that I see is to interact with frameworks (that didn\u2019t get the memo about inheritance). See also Effective Java: Favor Composition Over Inheritance .","title":"Inheritance"},{"location":"2020-12-12-composition/#n1","text":"There is a consequence of applying composition to design. I often call it the N+1 situation, and it goes like this: Let\u2019s say I start off with one component. Now I start understanding the requirements and responsibilities. Assuming I end up with three distinct responsibilities, ergo three different components. In order to achieve the overall goal I don\u2019t need three pieces, I need one whole. That means I need something that puts the three pieces together, i.e. the integration part. Sometimes, when I have more than just three components, I might even need multiple integrations. I often try to manage expectations by stating early on, that we should expect N+1 components in the end. It\u2019s also important to push back on the notion that a design with N (+1) components is more complex than the original design with just one. Complexity is not determined by the number of parts, but the number of connections. The original one-size-fits-all component had those connections already, but they were implicit and hidden. Yet they still hurt, because I need to understand them in order to successfully work with said component.","title":"N+1"},{"location":"2020-12-12-composition/#references","text":"Composition over inheritance Rich Hickey - Simple Made Easy","title":"References"},{"location":"2020-12-12-staged-builders/","text":"[..] often referred to as a wizard for building objects. Another pattern that I like to use a lot is Staged Builder . The traditional implementation of the Builder pattern is usually not very safe against misuse. It\u2019s a pattern that helps with Compile time > runtime because it shifts validation from runtime to compile time. Let\u2019s say there is a builder that produces a User. final var user = new UserBuilder () // misses first name, which is required . withLastname ( \"..\" ) . build () The API of UserBuilder doesn\u2019t guide you how to properly use it. The staged builder pattern introduces a proper interface, multiple in fact, without the need to change the builder implementation itself. Apart from the fact that it should be package private then. interface FirstNameStage { LastNameStage withFirstName ( String firstName ); } interface LastNameStage { BuildStage withLastName ( String lastName ); } interface BuildStage { User build (); } See also Riptide: HttpBuilder which includes an example of mutually exclusive paths. References \u00b6 Step builder pattern Immutable objects: Staged builder Next level Java 8 staged builders","title":"Staged Builders"},{"location":"2020-12-12-staged-builders/#references","text":"Step builder pattern Immutable objects: Staged builder Next level Java 8 staged builders","title":"References"},{"location":"2020-12-13-primitive-obsession/","text":"Primitives have their use, but they shouldn\u2019t be our first choice. When it comes to expressing things like identifiers or age we often tend to immediately jump towards primitives: data class User ( val id : Int , val age : Int , val name : String , val email : String ) There are actually several issues with that. The compiler is no longer able to type-check. Possible errors, as outlined in the next code sample, are the result. Validation is either often forgotten, or shared as separate methods, not together with the values themselves. val id = 1337 val age = 36 val name = \"D. Fault\" val email = \"d.fault@example.org\" val user = User ( age , id , email , name ) Instead of low level primitives like Int , Boolean and String one should strive towards typed, immutable value objects: data class User ( val id : UserId , val age : Age , val name : String , val email : Email ) class UserId ( private val value : String ) { // TODO equals, hashCode, toString } class Age ( private val value : Int ) : Comparable < Age > { init { require ( value >= 0 ) } operator fun plus ( age : Age ) = Age ( value + age . value ) override fun compareTo ( other : Age ) = value . compareTo ( other . value ) // TODO equals, hashCode, toString } class Email ( private val value : String ) { init { EmailValidator (). validate ( value ) } // TODO equals, hashCode, toString } References \u00b6 Refactoring Guru: Primitive Obsession","title":"Primitive Obsession"},{"location":"2020-12-13-primitive-obsession/#references","text":"Refactoring Guru: Primitive Obsession","title":"References"},{"location":"2020-12-13-time-as-a-dependency/","text":"Dependency injection doesn\u2019t end now() . There are certain constructs and expressions that immediately raise a red flag, whenever I see them: now() within Instant , OffsetDateTime , etc. new Date() or Calendar.getInstance() (also because they are deprecated) current_date , current_time and current_timestamp Pretty much everything that uses the system clock. My main concern is that it makes the code hard to test, slow to test or both. Let\u2019s say I have this campaign class. A campaign has a start and end date. Now I\u2019d like to have an easy way to tell whether it\u2019s currently active: class Campaign ( private val start : Instant , private val end : Instant ) { fun isActive (): Boolean { val now = Instant . now () return start <= now && now <= end } } The code is relatively easy to understand, but it\u2019s almost impossible to test, unless I: Mock the static Instant.now() method Change the actual system clock for the test Produce dynamic start and end dates, depending on the current time Neither of those options is ideal. I\u2019d rather have a test that: Works only with constants Is independent of the system\u2019s clock it\u2019s running on Is fast, i.e. not waiting or sleeping @Test fun `campaign is active` () { val start = Instant . parse ( \"2020-12-13T11:00:00.00Z\" ) val end = Instant . parse ( \"2020-12-25T11:00:00.00Z\" ) val unit = Campaign ( start , end ) assertTrue ( unit . isActive ()) } In order to make that pass, I\u2019d change the code and test to: fun isActive ( now : Instant ): Boolean { return start <= now && now <= end } val now = Instant . parse ( \"2020-12-19T09:32:17.00Z\" ) assertTrue ( unit . isActive ( now )) I can now: Have as many of those tests as I want. Properly test the boundaries without running into race conditions. Check whether a campaign was active in the past or will be active in the future, just by passing in a different reference timestamp. There are cases where I can\u2019t or don\u2019t want to pass in an Instant directly. The next best thing is to introduce an indirect dependency onto a Clock . That clock is then passed in as a constructor argument. That dependency can be replaced by a fixed clock or a fake clock during tests. In production it would then be Clock.systemUTC() . Database \u00b6 Eliminating time dependency is not limited to traditional programming languages. Especially within the database queries, e.g. SQL, it applies in exactly the same way. Assuming I have this query to find active logins (not older than 5 minutes): SELECT COUNT ( 1 ) FROM logins WHERE AGE ( created_at , current_timestamp ) < '5 minutes' :: INTERVAL The query is pretty straightforward to write, but it\u2019s very hard to test. I can either execute an additional statement, exclusive to my test: @Test fun `only finds logins that are five minutes old or less` () { val login = login () execute ( \"UPDATE logins SET created_at = created_at - '5 Minutes'::INTERVAL WHERE id = ${ login . id } \" ) assertThat ( findLoginsLastFiveMinutes ()). isEmpty () } Or I can actually wait for 5 minutes. (Don\u2019t do that!) @Test fun `only finds logins that are five minutes old or less` () { val login = login () Thread . sleep ( Duration . ofMinutes ( 5 ). toMillis ()) assertThat ( findLoginsLastFiveMinutes ()). isEmpty () } If I rewrite the statement instead and depend on now being passed in: SELECT COUNT ( 1 ) FROM logins WHERE AGE ( created_at , : now ) < '5 minutes' :: INTERVAL Then I can change my test to: val clock = TestClock () val unit = UserRepository ( clock ) @Test fun `only finds logins that are five minutes old or less` () { val login = login () clock . fastForward ( Duration . ofMinutes ( 5 )) assertThat ( findLoginsLastFiveMinutes ()). isEmpty () } The benefits of doing that are huge: Test no longer needs to execute a custom SQL statement Test is not sleeping/waiting/idling, i.e. it\u2019s fast Production code is more powerful than before: I can now find active logins at an arbitrary point in time, if I want to. References \u00b6 Test Clock , a great small library to have a mutable Clock implementation","title":"Time as a dependency"},{"location":"2020-12-13-time-as-a-dependency/#database","text":"Eliminating time dependency is not limited to traditional programming languages. Especially within the database queries, e.g. SQL, it applies in exactly the same way. Assuming I have this query to find active logins (not older than 5 minutes): SELECT COUNT ( 1 ) FROM logins WHERE AGE ( created_at , current_timestamp ) < '5 minutes' :: INTERVAL The query is pretty straightforward to write, but it\u2019s very hard to test. I can either execute an additional statement, exclusive to my test: @Test fun `only finds logins that are five minutes old or less` () { val login = login () execute ( \"UPDATE logins SET created_at = created_at - '5 Minutes'::INTERVAL WHERE id = ${ login . id } \" ) assertThat ( findLoginsLastFiveMinutes ()). isEmpty () } Or I can actually wait for 5 minutes. (Don\u2019t do that!) @Test fun `only finds logins that are five minutes old or less` () { val login = login () Thread . sleep ( Duration . ofMinutes ( 5 ). toMillis ()) assertThat ( findLoginsLastFiveMinutes ()). isEmpty () } If I rewrite the statement instead and depend on now being passed in: SELECT COUNT ( 1 ) FROM logins WHERE AGE ( created_at , : now ) < '5 minutes' :: INTERVAL Then I can change my test to: val clock = TestClock () val unit = UserRepository ( clock ) @Test fun `only finds logins that are five minutes old or less` () { val login = login () clock . fastForward ( Duration . ofMinutes ( 5 )) assertThat ( findLoginsLastFiveMinutes ()). isEmpty () } The benefits of doing that are huge: Test no longer needs to execute a custom SQL statement Test is not sleeping/waiting/idling, i.e. it\u2019s fast Production code is more powerful than before: I can now find active logins at an arbitrary point in time, if I want to.","title":"Database"},{"location":"2020-12-13-time-as-a-dependency/#references","text":"Test Clock , a great small library to have a mutable Clock implementation","title":"References"}]}